<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.5.3" />
<title>blocksim.players API documentation</title>
<meta name="description" content="Standard player strategies for conducting the experiments. Each player is generated
with a name that serves as its identificator. Also, each player â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.name small{font-weight:normal}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title"><code>blocksim.players</code> module</h1>
</header>
<section id="section-intro">
<p>Standard player strategies for conducting the experiments. Each player is generated
with a name that serves as its identificator. Also, each player has to have 6 methods
called <code>add_hidden_block</code>, which saves a new hidden block created by the player,
<code>delete_hidden_block</code>, which deletes the reference to a hidden block created by the
player after revealing it, <code>add_known_block</code>, which saves a hidden block created by
another player, <code>strat</code>, which chooses a block to mine on top of, <code>publish</code>,
which chooses blocks to reveal, and <code>inform</code>, which chooses blocks to communicate
to other players.</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">&#34;&#34;&#34;Standard player strategies for conducting the experiments. Each player is generated
with a name that serves as its identificator. Also, each player has to have 6 methods
called ``add_hidden_block``, which saves a new hidden block created by the player,
``delete_hidden_block``, which deletes the reference to a hidden block created by the
player after revealing it, ``add_known_block``, which saves a hidden block created by
another player, ``strat``, which chooses a block to mine on top of, ``publish``,
which chooses blocks to reveal, and ``inform``, which chooses blocks to communicate
to other players.&#34;&#34;&#34;

from random import sample

from .simulation import Block


class DefPlayerRandom:

    &#34;&#34;&#34;Generate player that uses the default strategy but, when there is a tie in
    max depth, the algorithm chooses randomly between the deepest blocks to mine.&#34;&#34;&#34;

    def __init__(self, name):

        &#34;&#34;&#34;Parameters
        ----------
        
        name : string
            identifier for the player&#34;&#34;&#34;

        self.name = name
        self.hidden_blocks = []
        self.known_blocks = []

    def add_hidden_block(self, block):

        &#34;&#34;&#34;Save a hidden block created by current player.
        
        Parameters
        ----------
        
        block : Block
            new hidden block to be save&#34;&#34;&#34;

        self.hidden_blocks.append(block)

    def delete_hidden_block(self, block):

        &#34;&#34;&#34;Delete reference to hidden block created by the current player after
        revealing it.
        
        Parameters
        ----------
        
        block : Block
            block to be forgotten&#34;&#34;&#34;

        self.hidden_blocks.remove(block)
    
    def add_known_block(self, block):

        &#34;&#34;&#34;Save a hidden block created by another player.
        
        Parameters
        ----------
        
        block : Block
            block to be saved&#34;&#34;&#34;

        self.known_blocks.append(block)

    def strat(self, struct):

        &#34;&#34;&#34;Choose a block to mine on top of. Choose a random block from the
        deepest blocks in the structure.
        
        Parameters
        ----------
        
        struct : Structure
            data structure of the simulation
            
        Results
        -------
        
        block : Block
            chosen block to mine on top of&#34;&#34;&#34;

        return sample(struct.deep_blocks, 1)[0]

    def publish(self, struct, end=False):

        &#34;&#34;&#34;Choose blocks to reveal. Reveal all hidden blocks.
        
        Parameters
        ----------
        
        struct : Structure
            data structure of the simulation
        end : bool
            flag indicating whether the method is being called after the
            simulation has ended or before that
            
        Results
        -------
        
        pub_blocks : set
            set containing blocks to be revealed&#34;&#34;&#34;

        prev_blocks = self.hidden_blocks
        self.hidden_blocks = []
        return set(prev_blocks)

    def inform(self, struct, end=False):

        &#34;&#34;&#34;Choose blocks to communicate to other players. Don&#39;t communicate any
        block.
        
        Parameters
        ----------
        
        struct : Structure
            data structure of the simulation
        end : bool
            flag indicating whether the method is being called after the
            simulation has ended or before that
            
        Results
        -------
        
        com_blocks : dict
            dictionary indicating which blocks to communicate to which players&#34;&#34;&#34;

        return dict()


class DefPlayer:

    &#34;&#34;&#34;Generate player that uses the default strategy. When there is a tie in
    max depth, the algorithm chooses the branch that gives the current player
    the max amount of payoff.&#34;&#34;&#34;

    def __init__(self, name):

        &#34;&#34;&#34;Parameters
        ----------
        
        name : string
            identifier for the player&#34;&#34;&#34;

        self.name = name
        self.hidden_blocks = []
        self.known_blocks = []

    def add_hidden_block(self, block):

        &#34;&#34;&#34;Save a hidden block created by current player.
        
        Parameters
        ----------
        
        block : Block
            new hidden block to be save&#34;&#34;&#34;

        self.hidden_blocks.append(block)

    def delete_hidden_block(self, block):

        &#34;&#34;&#34;Delete reference to hidden block created by the current player after
        revealing it.
        
        Parameters
        ----------
        
        block : Block
            block to be forgotten&#34;&#34;&#34;

        self.hidden_blocks.remove(block)
    
    def add_known_block(self, block):

        &#34;&#34;&#34;Save a hidden block created by another player.
        
        Parameters
        ----------
        
        block : Block
            block to be saved&#34;&#34;&#34;

        self.known_blocks.append(block)

    def strat(self, struct):

        &#34;&#34;&#34;Choose a block to mine on top of. Choose the deepest block in the
        structure that belongs to the branch that maximizes the current player&#39;s
        payoff.
        
        Parameters
        ----------
        
        struct : Structure
            data structure of the simulation
            
        Results
        -------
        
        block : Block
            chosen block to mine on top of&#34;&#34;&#34;

        next_blocks = struct.deep_blocks.copy()

        if len(next_blocks) &gt; 1:
            while len(next_blocks) &gt; 1:
                old_blocks = next_blocks
                next_blocks = set()
                for block in old_blocks:
                    next_blocks.add(block.parent)

            common_block = next_blocks.pop()
            block_payoff = {block: struct.payoff(block, common_block, struct.base)
                            for block in struct.deep_blocks}
            for block in block_payoff:
                if self.name not in block_payoff[block]:
                    block_payoff[block][self.name] = {&#34;block_number&#34;: 0, &#34;payoff&#34;: 0}
            max_payoff = max(block_payoff, key=lambda x: block_payoff[x][self.name][&#34;payoff&#34;])
            max_payoff_blocks = set(filter(lambda x: block_payoff[x][self.name][&#34;payoff&#34;] == block_payoff[max_payoff][self.name][&#34;payoff&#34;], struct.deep_blocks))
            sel_block = max_payoff_blocks.pop()
        else:
            sel_block = next_blocks.pop()

        return sel_block

    def publish(self, struct, end=False):

        &#34;&#34;&#34;Choose blocks to reveal. Reveal all hidden blocks.
        
        Parameters
        ----------
        
        struct : Structure
            data structure of the simulation
        end : bool
            flag indicating whether the method is being called after the
            simulation has ended or before that
            
        Results
        -------
        
        pub_blocks : set
            set containing blocks to be revealed&#34;&#34;&#34;

        prev_blocks = self.hidden_blocks
        self.hidden_blocks = []
        return set(prev_blocks)

    def inform(self, struct, end=False):

        &#34;&#34;&#34;Choose blocks to communicate to other players. Don&#39;t communicate any
        block.
        
        Parameters
        ----------
        
        struct : Structure
            data structure of the simulation
        end : bool
            flag indicating whether the method is being called after the
            simulation has ended or before that
            
        Results
        -------
        
        com_blocks : dict
            dictionary indicating which blocks to communicate to which players&#34;&#34;&#34;

        return dict()


class SelfPlayer:

    &#34;&#34;&#34;Generate player that uses the selfish strategy. Once the player discovers
    a new block, they don&#39;t reveal it unless another branch catches up to its
    depth decremented by one. For example, if the hidden branch that the player
    has created has a depth of ``n`` and there is another branch of depth
    ``n - 2``, the player discloses every block that has a depth of ``n - 1``
    or less.&#34;&#34;&#34;

    def __init__(self, name):

        &#34;&#34;&#34;Parameters
        ----------
        
        name : string
            identifier for the player&#34;&#34;&#34;

        self.name = name
        self.hidden_blocks = []
        self.known_blocks = []
        self.just_forked = False
        self.first_block = None
        self.last_published = None

    def add_hidden_block(self, block):

        &#34;&#34;&#34;Save a hidden block created by current player.
        
        Parameters
        ----------
        
        block : Block
            new hidden block to be save&#34;&#34;&#34;

        self.hidden_blocks.append(block)

    def delete_hidden_block(self, block):

        &#34;&#34;&#34;Delete reference to hidden block created by the current player after
        revealing it.
        
        Parameters
        ----------
        
        block : Block
            block to be forgotten&#34;&#34;&#34;

        self.hidden_blocks.remove(block)
    
    def add_known_block(self, block):

        &#34;&#34;&#34;Save a hidden block created by another player.
        
        Parameters
        ----------
        
        block : Block
            block to be saved&#34;&#34;&#34;

        self.known_blocks.append(block)

    def strat(self, struct):

        &#34;&#34;&#34;Choose a block to mine on top of. Chooses the same way that the
        default strategy would, unless the player has hidden blocks, in which
        case they mine on top of the last hidden block they have placed.
        
        Parameters
        ----------
        
        struct : Structure
            data structure of the simulation
            
        Results
        -------
        
        block : Block
            chosen block to mine on top of&#34;&#34;&#34;

        if self.hidden_blocks:
            return self.hidden_blocks[-1]
        
        next_blocks = struct.deep_blocks.copy()

        if self.last_published is not None and self.last_published.depth == struct.depth:
            if len(struct.deep_blocks) == 1:
                self.just_forked = True
            sel_block = self.last_published
        else:
            sel_block = next_blocks.pop()
            self.just_forked = True

        return sel_block

    def publish(self, struct, end=False):

        &#34;&#34;&#34;Choose blocks to reveal. As explained in the documentation for
        SelfPlayer, one only reveals a block if another branch has caught
        up with its depth decremented by one.
        
        Parameters
        ----------
        
        struct : Structure
            data structure of the simulation
        end : bool
            flag indicating whether the method is being called after the
            simulation has ended or before that
            
        Results
        -------
        
        pub_blocks : set
            set containing blocks to be revealed&#34;&#34;&#34;

        if end:
            prev_blocks = self.hidden_blocks
            self.hidden_blocks = list(filter(lambda x: x.parent.hidden, self.hidden_blocks))
            return set(filter(lambda x: not x.parent.hidden, prev_blocks))

        if self.just_forked:
            self.just_forked = False
            self.first_block = self.hidden_blocks[-1]
            return set()
        elif self.hidden_blocks:
            if self.hidden_blocks == [self.first_block]:
                if self.first_block.depth == struct.depth:
                    prev_blocks = self.hidden_blocks
                    self.hidden_blocks = []
                    self.last_published = self.first_block
                    return set(prev_blocks)
                else:
                    return set()
            else:
                if self.hidden_blocks[-1].depth &lt;= struct.depth + 1:
                    prev_blocks = self.hidden_blocks
                    self.hidden_blocks = list(filter(lambda x: x.parent.hidden, self.hidden_blocks))
                    publish = set(filter(lambda x: not x.parent.hidden, prev_blocks))
                    self.last_published = max(publish, key=lambda x: x.depth)
                    return publish
                else:
                    prev_blocks = self.hidden_blocks
                    self.hidden_blocks = list(filter(lambda x: x.parent.hidden or x.depth &gt; struct.depth, self.hidden_blocks))
                    publish = set(filter(lambda x: not x.parent.hidden and x.depth &lt;= struct.depth, prev_blocks))
                    self.last_published = max(publish, default=self.last_published, key=lambda x: x.depth)
                    return publish
        else:
            return set()

    def inform(self, struct, end=False):

        &#34;&#34;&#34;Choose blocks to communicate to other players. Don&#39;t communicate any
        block.
        
        Parameters
        ----------
        
        struct : Structure
            data structure of the simulation
        end : bool
            flag indicating whether the method is being called after the
            simulation has ended or before that
            
        Results
        -------
        
        com_blocks : dict
            dictionary indicating which blocks to communicate to which players&#34;&#34;&#34;

        return dict()

class AFPlayer:

    &#34;&#34;&#34;Generate player that uses the always fork strategy. At first the
    player mines on top of the genesis block. After that, they only mine on
    top of the last block they have placed in the structure.&#34;&#34;&#34;

    def __init__(self, name):

        &#34;&#34;&#34;Parameters
        ----------
        
        name : string
            identifier for the player&#34;&#34;&#34;

        self.name = name
        self.hidden_blocks = []
        self.known_blocks = []
        self.last_block = None

    def add_hidden_block(self, block):

        &#34;&#34;&#34;Save a hidden block created by current player.
        
        Parameters
        ----------
        
        block : Block
            new hidden block to be save&#34;&#34;&#34;

        self.hidden_blocks.append(block)

    def delete_hidden_block(self, block):

        &#34;&#34;&#34;Delete reference to hidden block created by the current player after
        revealing it.
        
        Parameters
        ----------
        
        block : Block
            block to be forgotten&#34;&#34;&#34;

        self.hidden_blocks.remove(block)
    
    def add_known_block(self, block):

        &#34;&#34;&#34;Save a hidden block created by another player.
        
        Parameters
        ----------
        
        block : Block
            block to be saved&#34;&#34;&#34;

        self.known_blocks.append(block)

    def strat(self, struct):

        &#34;&#34;&#34;Choose a block to mine on top of. Chooses the genesis block if
        the player hasn&#39;t placed any blocks. Otherwise, chooses the last block
        placed by the player.
        
        Parameters
        ----------
        
        struct : Structure
            data structure of the simulation
            
        Results
        -------
        
        block : Block
            chosen block to mine on top of&#34;&#34;&#34;

        if self.last_block:
            return self.last_block
        else:
            block = struct.deep_blocks.pop()
            struct.deep_blocks.add(block)
            return block

    def publish(self, struct, end=False):

        &#34;&#34;&#34;Choose blocks to reveal. Reveal all hidden blocks.
        
        Parameters
        ----------
        
        struct : Structure
            data structure of the simulation
        end : bool
            flag indicating whether the method is being called after the
            simulation has ended or before that
            
        Results
        -------
        
        pub_blocks : set
            set containing blocks to be revealed&#34;&#34;&#34;

        if self.hidden_blocks:
            self.last_block = self.hidden_blocks[-1]
            prev_blocks = self.hidden_blocks
            self.hidden_blocks = []
            return set(prev_blocks)
        else:
            return set()

    def inform(self, struct, end=False):

        &#34;&#34;&#34;Choose blocks to communicate to other players. Don&#39;t communicate any
        block.
        
        Parameters
        ----------
        
        struct : Structure
            data structure of the simulation
        end : bool
            flag indicating whether the method is being called after the
            simulation has ended or before that
            
        Results
        -------
        
        com_blocks : dict
            dictionary indicating which blocks to communicate to which players&#34;&#34;&#34;

        return dict()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="blocksim.players.AFPlayer"><code class="flex name class">
<span>class <span class="ident">AFPlayer</span></span>
</code></dt>
<dd>
<section class="desc"><p>Generate player that uses the always fork strategy. At first the
player mines on top of the genesis block. After that, they only mine on
top of the last block they have placed in the structure.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class AFPlayer:

    &#34;&#34;&#34;Generate player that uses the always fork strategy. At first the
    player mines on top of the genesis block. After that, they only mine on
    top of the last block they have placed in the structure.&#34;&#34;&#34;

    def __init__(self, name):

        &#34;&#34;&#34;Parameters
        ----------
        
        name : string
            identifier for the player&#34;&#34;&#34;

        self.name = name
        self.hidden_blocks = []
        self.known_blocks = []
        self.last_block = None

    def add_hidden_block(self, block):

        &#34;&#34;&#34;Save a hidden block created by current player.
        
        Parameters
        ----------
        
        block : Block
            new hidden block to be save&#34;&#34;&#34;

        self.hidden_blocks.append(block)

    def delete_hidden_block(self, block):

        &#34;&#34;&#34;Delete reference to hidden block created by the current player after
        revealing it.
        
        Parameters
        ----------
        
        block : Block
            block to be forgotten&#34;&#34;&#34;

        self.hidden_blocks.remove(block)
    
    def add_known_block(self, block):

        &#34;&#34;&#34;Save a hidden block created by another player.
        
        Parameters
        ----------
        
        block : Block
            block to be saved&#34;&#34;&#34;

        self.known_blocks.append(block)

    def strat(self, struct):

        &#34;&#34;&#34;Choose a block to mine on top of. Chooses the genesis block if
        the player hasn&#39;t placed any blocks. Otherwise, chooses the last block
        placed by the player.
        
        Parameters
        ----------
        
        struct : Structure
            data structure of the simulation
            
        Results
        -------
        
        block : Block
            chosen block to mine on top of&#34;&#34;&#34;

        if self.last_block:
            return self.last_block
        else:
            block = struct.deep_blocks.pop()
            struct.deep_blocks.add(block)
            return block

    def publish(self, struct, end=False):

        &#34;&#34;&#34;Choose blocks to reveal. Reveal all hidden blocks.
        
        Parameters
        ----------
        
        struct : Structure
            data structure of the simulation
        end : bool
            flag indicating whether the method is being called after the
            simulation has ended or before that
            
        Results
        -------
        
        pub_blocks : set
            set containing blocks to be revealed&#34;&#34;&#34;

        if self.hidden_blocks:
            self.last_block = self.hidden_blocks[-1]
            prev_blocks = self.hidden_blocks
            self.hidden_blocks = []
            return set(prev_blocks)
        else:
            return set()

    def inform(self, struct, end=False):

        &#34;&#34;&#34;Choose blocks to communicate to other players. Don&#39;t communicate any
        block.
        
        Parameters
        ----------
        
        struct : Structure
            data structure of the simulation
        end : bool
            flag indicating whether the method is being called after the
            simulation has ended or before that
            
        Results
        -------
        
        com_blocks : dict
            dictionary indicating which blocks to communicate to which players&#34;&#34;&#34;

        return dict()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="blocksim.players.AFPlayer.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code></dt>
<dd>identifier for the player</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def __init__(self, name):

    &#34;&#34;&#34;Parameters
    ----------
    
    name : string
        identifier for the player&#34;&#34;&#34;

    self.name = name
    self.hidden_blocks = []
    self.known_blocks = []
    self.last_block = None</code></pre>
</details>
</dd>
<dt id="blocksim.players.AFPlayer.add_hidden_block"><code class="name flex">
<span>def <span class="ident">add_hidden_block</span></span>(<span>self, block)</span>
</code></dt>
<dd>
<section class="desc"><p>Save a hidden block created by current player.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block</code></strong> :&ensp;<code>Block</code></dt>
<dd>new hidden block to be save</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_hidden_block(self, block):

    &#34;&#34;&#34;Save a hidden block created by current player.
    
    Parameters
    ----------
    
    block : Block
        new hidden block to be save&#34;&#34;&#34;

    self.hidden_blocks.append(block)</code></pre>
</details>
</dd>
<dt id="blocksim.players.AFPlayer.add_known_block"><code class="name flex">
<span>def <span class="ident">add_known_block</span></span>(<span>self, block)</span>
</code></dt>
<dd>
<section class="desc"><p>Save a hidden block created by another player.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block</code></strong> :&ensp;<code>Block</code></dt>
<dd>block to be saved</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_known_block(self, block):

    &#34;&#34;&#34;Save a hidden block created by another player.
    
    Parameters
    ----------
    
    block : Block
        block to be saved&#34;&#34;&#34;

    self.known_blocks.append(block)</code></pre>
</details>
</dd>
<dt id="blocksim.players.AFPlayer.delete_hidden_block"><code class="name flex">
<span>def <span class="ident">delete_hidden_block</span></span>(<span>self, block)</span>
</code></dt>
<dd>
<section class="desc"><p>Delete reference to hidden block created by the current player after
revealing it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block</code></strong> :&ensp;<code>Block</code></dt>
<dd>block to be forgotten</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def delete_hidden_block(self, block):

    &#34;&#34;&#34;Delete reference to hidden block created by the current player after
    revealing it.
    
    Parameters
    ----------
    
    block : Block
        block to be forgotten&#34;&#34;&#34;

    self.hidden_blocks.remove(block)</code></pre>
</details>
</dd>
<dt id="blocksim.players.AFPlayer.inform"><code class="name flex">
<span>def <span class="ident">inform</span></span>(<span>self, struct, end=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Choose blocks to communicate to other players. Don't communicate any
block.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>struct</code></strong> :&ensp;<code>Structure</code></dt>
<dd>data structure of the simulation</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>bool</code></dt>
<dd>flag indicating whether the method is being called after the
simulation has ended or before that</dd>
</dl>
<h2 id="results">Results</h2>
<dl>
<dt><strong><code>com_blocks</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary indicating which blocks to communicate to which players</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def inform(self, struct, end=False):

    &#34;&#34;&#34;Choose blocks to communicate to other players. Don&#39;t communicate any
    block.
    
    Parameters
    ----------
    
    struct : Structure
        data structure of the simulation
    end : bool
        flag indicating whether the method is being called after the
        simulation has ended or before that
        
    Results
    -------
    
    com_blocks : dict
        dictionary indicating which blocks to communicate to which players&#34;&#34;&#34;

    return dict()</code></pre>
</details>
</dd>
<dt id="blocksim.players.AFPlayer.publish"><code class="name flex">
<span>def <span class="ident">publish</span></span>(<span>self, struct, end=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Choose blocks to reveal. Reveal all hidden blocks.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>struct</code></strong> :&ensp;<code>Structure</code></dt>
<dd>data structure of the simulation</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>bool</code></dt>
<dd>flag indicating whether the method is being called after the
simulation has ended or before that</dd>
</dl>
<h2 id="results">Results</h2>
<dl>
<dt><strong><code>pub_blocks</code></strong> :&ensp;<code>set</code></dt>
<dd>set containing blocks to be revealed</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def publish(self, struct, end=False):

    &#34;&#34;&#34;Choose blocks to reveal. Reveal all hidden blocks.
    
    Parameters
    ----------
    
    struct : Structure
        data structure of the simulation
    end : bool
        flag indicating whether the method is being called after the
        simulation has ended or before that
        
    Results
    -------
    
    pub_blocks : set
        set containing blocks to be revealed&#34;&#34;&#34;

    if self.hidden_blocks:
        self.last_block = self.hidden_blocks[-1]
        prev_blocks = self.hidden_blocks
        self.hidden_blocks = []
        return set(prev_blocks)
    else:
        return set()</code></pre>
</details>
</dd>
<dt id="blocksim.players.AFPlayer.strat"><code class="name flex">
<span>def <span class="ident">strat</span></span>(<span>self, struct)</span>
</code></dt>
<dd>
<section class="desc"><p>Choose a block to mine on top of. Chooses the genesis block if
the player hasn't placed any blocks. Otherwise, chooses the last block
placed by the player.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>struct</code></strong> :&ensp;<code>Structure</code></dt>
<dd>data structure of the simulation</dd>
</dl>
<h2 id="results">Results</h2>
<dl>
<dt><strong><code>block</code></strong> :&ensp;<code>Block</code></dt>
<dd>chosen block to mine on top of</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def strat(self, struct):

    &#34;&#34;&#34;Choose a block to mine on top of. Chooses the genesis block if
    the player hasn&#39;t placed any blocks. Otherwise, chooses the last block
    placed by the player.
    
    Parameters
    ----------
    
    struct : Structure
        data structure of the simulation
        
    Results
    -------
    
    block : Block
        chosen block to mine on top of&#34;&#34;&#34;

    if self.last_block:
        return self.last_block
    else:
        block = struct.deep_blocks.pop()
        struct.deep_blocks.add(block)
        return block</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="blocksim.players.DefPlayer"><code class="flex name class">
<span>class <span class="ident">DefPlayer</span></span>
</code></dt>
<dd>
<section class="desc"><p>Generate player that uses the default strategy. When there is a tie in
max depth, the algorithm chooses the branch that gives the current player
the max amount of payoff.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class DefPlayer:

    &#34;&#34;&#34;Generate player that uses the default strategy. When there is a tie in
    max depth, the algorithm chooses the branch that gives the current player
    the max amount of payoff.&#34;&#34;&#34;

    def __init__(self, name):

        &#34;&#34;&#34;Parameters
        ----------
        
        name : string
            identifier for the player&#34;&#34;&#34;

        self.name = name
        self.hidden_blocks = []
        self.known_blocks = []

    def add_hidden_block(self, block):

        &#34;&#34;&#34;Save a hidden block created by current player.
        
        Parameters
        ----------
        
        block : Block
            new hidden block to be save&#34;&#34;&#34;

        self.hidden_blocks.append(block)

    def delete_hidden_block(self, block):

        &#34;&#34;&#34;Delete reference to hidden block created by the current player after
        revealing it.
        
        Parameters
        ----------
        
        block : Block
            block to be forgotten&#34;&#34;&#34;

        self.hidden_blocks.remove(block)
    
    def add_known_block(self, block):

        &#34;&#34;&#34;Save a hidden block created by another player.
        
        Parameters
        ----------
        
        block : Block
            block to be saved&#34;&#34;&#34;

        self.known_blocks.append(block)

    def strat(self, struct):

        &#34;&#34;&#34;Choose a block to mine on top of. Choose the deepest block in the
        structure that belongs to the branch that maximizes the current player&#39;s
        payoff.
        
        Parameters
        ----------
        
        struct : Structure
            data structure of the simulation
            
        Results
        -------
        
        block : Block
            chosen block to mine on top of&#34;&#34;&#34;

        next_blocks = struct.deep_blocks.copy()

        if len(next_blocks) &gt; 1:
            while len(next_blocks) &gt; 1:
                old_blocks = next_blocks
                next_blocks = set()
                for block in old_blocks:
                    next_blocks.add(block.parent)

            common_block = next_blocks.pop()
            block_payoff = {block: struct.payoff(block, common_block, struct.base)
                            for block in struct.deep_blocks}
            for block in block_payoff:
                if self.name not in block_payoff[block]:
                    block_payoff[block][self.name] = {&#34;block_number&#34;: 0, &#34;payoff&#34;: 0}
            max_payoff = max(block_payoff, key=lambda x: block_payoff[x][self.name][&#34;payoff&#34;])
            max_payoff_blocks = set(filter(lambda x: block_payoff[x][self.name][&#34;payoff&#34;] == block_payoff[max_payoff][self.name][&#34;payoff&#34;], struct.deep_blocks))
            sel_block = max_payoff_blocks.pop()
        else:
            sel_block = next_blocks.pop()

        return sel_block

    def publish(self, struct, end=False):

        &#34;&#34;&#34;Choose blocks to reveal. Reveal all hidden blocks.
        
        Parameters
        ----------
        
        struct : Structure
            data structure of the simulation
        end : bool
            flag indicating whether the method is being called after the
            simulation has ended or before that
            
        Results
        -------
        
        pub_blocks : set
            set containing blocks to be revealed&#34;&#34;&#34;

        prev_blocks = self.hidden_blocks
        self.hidden_blocks = []
        return set(prev_blocks)

    def inform(self, struct, end=False):

        &#34;&#34;&#34;Choose blocks to communicate to other players. Don&#39;t communicate any
        block.
        
        Parameters
        ----------
        
        struct : Structure
            data structure of the simulation
        end : bool
            flag indicating whether the method is being called after the
            simulation has ended or before that
            
        Results
        -------
        
        com_blocks : dict
            dictionary indicating which blocks to communicate to which players&#34;&#34;&#34;

        return dict()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="blocksim.players.DefPlayer.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code></dt>
<dd>identifier for the player</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def __init__(self, name):

    &#34;&#34;&#34;Parameters
    ----------
    
    name : string
        identifier for the player&#34;&#34;&#34;

    self.name = name
    self.hidden_blocks = []
    self.known_blocks = []</code></pre>
</details>
</dd>
<dt id="blocksim.players.DefPlayer.add_hidden_block"><code class="name flex">
<span>def <span class="ident">add_hidden_block</span></span>(<span>self, block)</span>
</code></dt>
<dd>
<section class="desc"><p>Save a hidden block created by current player.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block</code></strong> :&ensp;<code>Block</code></dt>
<dd>new hidden block to be save</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_hidden_block(self, block):

    &#34;&#34;&#34;Save a hidden block created by current player.
    
    Parameters
    ----------
    
    block : Block
        new hidden block to be save&#34;&#34;&#34;

    self.hidden_blocks.append(block)</code></pre>
</details>
</dd>
<dt id="blocksim.players.DefPlayer.add_known_block"><code class="name flex">
<span>def <span class="ident">add_known_block</span></span>(<span>self, block)</span>
</code></dt>
<dd>
<section class="desc"><p>Save a hidden block created by another player.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block</code></strong> :&ensp;<code>Block</code></dt>
<dd>block to be saved</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_known_block(self, block):

    &#34;&#34;&#34;Save a hidden block created by another player.
    
    Parameters
    ----------
    
    block : Block
        block to be saved&#34;&#34;&#34;

    self.known_blocks.append(block)</code></pre>
</details>
</dd>
<dt id="blocksim.players.DefPlayer.delete_hidden_block"><code class="name flex">
<span>def <span class="ident">delete_hidden_block</span></span>(<span>self, block)</span>
</code></dt>
<dd>
<section class="desc"><p>Delete reference to hidden block created by the current player after
revealing it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block</code></strong> :&ensp;<code>Block</code></dt>
<dd>block to be forgotten</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def delete_hidden_block(self, block):

    &#34;&#34;&#34;Delete reference to hidden block created by the current player after
    revealing it.
    
    Parameters
    ----------
    
    block : Block
        block to be forgotten&#34;&#34;&#34;

    self.hidden_blocks.remove(block)</code></pre>
</details>
</dd>
<dt id="blocksim.players.DefPlayer.inform"><code class="name flex">
<span>def <span class="ident">inform</span></span>(<span>self, struct, end=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Choose blocks to communicate to other players. Don't communicate any
block.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>struct</code></strong> :&ensp;<code>Structure</code></dt>
<dd>data structure of the simulation</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>bool</code></dt>
<dd>flag indicating whether the method is being called after the
simulation has ended or before that</dd>
</dl>
<h2 id="results">Results</h2>
<dl>
<dt><strong><code>com_blocks</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary indicating which blocks to communicate to which players</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def inform(self, struct, end=False):

    &#34;&#34;&#34;Choose blocks to communicate to other players. Don&#39;t communicate any
    block.
    
    Parameters
    ----------
    
    struct : Structure
        data structure of the simulation
    end : bool
        flag indicating whether the method is being called after the
        simulation has ended or before that
        
    Results
    -------
    
    com_blocks : dict
        dictionary indicating which blocks to communicate to which players&#34;&#34;&#34;

    return dict()</code></pre>
</details>
</dd>
<dt id="blocksim.players.DefPlayer.publish"><code class="name flex">
<span>def <span class="ident">publish</span></span>(<span>self, struct, end=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Choose blocks to reveal. Reveal all hidden blocks.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>struct</code></strong> :&ensp;<code>Structure</code></dt>
<dd>data structure of the simulation</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>bool</code></dt>
<dd>flag indicating whether the method is being called after the
simulation has ended or before that</dd>
</dl>
<h2 id="results">Results</h2>
<dl>
<dt><strong><code>pub_blocks</code></strong> :&ensp;<code>set</code></dt>
<dd>set containing blocks to be revealed</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def publish(self, struct, end=False):

    &#34;&#34;&#34;Choose blocks to reveal. Reveal all hidden blocks.
    
    Parameters
    ----------
    
    struct : Structure
        data structure of the simulation
    end : bool
        flag indicating whether the method is being called after the
        simulation has ended or before that
        
    Results
    -------
    
    pub_blocks : set
        set containing blocks to be revealed&#34;&#34;&#34;

    prev_blocks = self.hidden_blocks
    self.hidden_blocks = []
    return set(prev_blocks)</code></pre>
</details>
</dd>
<dt id="blocksim.players.DefPlayer.strat"><code class="name flex">
<span>def <span class="ident">strat</span></span>(<span>self, struct)</span>
</code></dt>
<dd>
<section class="desc"><p>Choose a block to mine on top of. Choose the deepest block in the
structure that belongs to the branch that maximizes the current player's
payoff.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>struct</code></strong> :&ensp;<code>Structure</code></dt>
<dd>data structure of the simulation</dd>
</dl>
<h2 id="results">Results</h2>
<dl>
<dt><strong><code>block</code></strong> :&ensp;<code>Block</code></dt>
<dd>chosen block to mine on top of</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def strat(self, struct):

    &#34;&#34;&#34;Choose a block to mine on top of. Choose the deepest block in the
    structure that belongs to the branch that maximizes the current player&#39;s
    payoff.
    
    Parameters
    ----------
    
    struct : Structure
        data structure of the simulation
        
    Results
    -------
    
    block : Block
        chosen block to mine on top of&#34;&#34;&#34;

    next_blocks = struct.deep_blocks.copy()

    if len(next_blocks) &gt; 1:
        while len(next_blocks) &gt; 1:
            old_blocks = next_blocks
            next_blocks = set()
            for block in old_blocks:
                next_blocks.add(block.parent)

        common_block = next_blocks.pop()
        block_payoff = {block: struct.payoff(block, common_block, struct.base)
                        for block in struct.deep_blocks}
        for block in block_payoff:
            if self.name not in block_payoff[block]:
                block_payoff[block][self.name] = {&#34;block_number&#34;: 0, &#34;payoff&#34;: 0}
        max_payoff = max(block_payoff, key=lambda x: block_payoff[x][self.name][&#34;payoff&#34;])
        max_payoff_blocks = set(filter(lambda x: block_payoff[x][self.name][&#34;payoff&#34;] == block_payoff[max_payoff][self.name][&#34;payoff&#34;], struct.deep_blocks))
        sel_block = max_payoff_blocks.pop()
    else:
        sel_block = next_blocks.pop()

    return sel_block</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="blocksim.players.DefPlayerRandom"><code class="flex name class">
<span>class <span class="ident">DefPlayerRandom</span></span>
</code></dt>
<dd>
<section class="desc"><p>Generate player that uses the default strategy but, when there is a tie in
max depth, the algorithm chooses randomly between the deepest blocks to mine.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class DefPlayerRandom:

    &#34;&#34;&#34;Generate player that uses the default strategy but, when there is a tie in
    max depth, the algorithm chooses randomly between the deepest blocks to mine.&#34;&#34;&#34;

    def __init__(self, name):

        &#34;&#34;&#34;Parameters
        ----------
        
        name : string
            identifier for the player&#34;&#34;&#34;

        self.name = name
        self.hidden_blocks = []
        self.known_blocks = []

    def add_hidden_block(self, block):

        &#34;&#34;&#34;Save a hidden block created by current player.
        
        Parameters
        ----------
        
        block : Block
            new hidden block to be save&#34;&#34;&#34;

        self.hidden_blocks.append(block)

    def delete_hidden_block(self, block):

        &#34;&#34;&#34;Delete reference to hidden block created by the current player after
        revealing it.
        
        Parameters
        ----------
        
        block : Block
            block to be forgotten&#34;&#34;&#34;

        self.hidden_blocks.remove(block)
    
    def add_known_block(self, block):

        &#34;&#34;&#34;Save a hidden block created by another player.
        
        Parameters
        ----------
        
        block : Block
            block to be saved&#34;&#34;&#34;

        self.known_blocks.append(block)

    def strat(self, struct):

        &#34;&#34;&#34;Choose a block to mine on top of. Choose a random block from the
        deepest blocks in the structure.
        
        Parameters
        ----------
        
        struct : Structure
            data structure of the simulation
            
        Results
        -------
        
        block : Block
            chosen block to mine on top of&#34;&#34;&#34;

        return sample(struct.deep_blocks, 1)[0]

    def publish(self, struct, end=False):

        &#34;&#34;&#34;Choose blocks to reveal. Reveal all hidden blocks.
        
        Parameters
        ----------
        
        struct : Structure
            data structure of the simulation
        end : bool
            flag indicating whether the method is being called after the
            simulation has ended or before that
            
        Results
        -------
        
        pub_blocks : set
            set containing blocks to be revealed&#34;&#34;&#34;

        prev_blocks = self.hidden_blocks
        self.hidden_blocks = []
        return set(prev_blocks)

    def inform(self, struct, end=False):

        &#34;&#34;&#34;Choose blocks to communicate to other players. Don&#39;t communicate any
        block.
        
        Parameters
        ----------
        
        struct : Structure
            data structure of the simulation
        end : bool
            flag indicating whether the method is being called after the
            simulation has ended or before that
            
        Results
        -------
        
        com_blocks : dict
            dictionary indicating which blocks to communicate to which players&#34;&#34;&#34;

        return dict()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="blocksim.players.DefPlayerRandom.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code></dt>
<dd>identifier for the player</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def __init__(self, name):

    &#34;&#34;&#34;Parameters
    ----------
    
    name : string
        identifier for the player&#34;&#34;&#34;

    self.name = name
    self.hidden_blocks = []
    self.known_blocks = []</code></pre>
</details>
</dd>
<dt id="blocksim.players.DefPlayerRandom.add_hidden_block"><code class="name flex">
<span>def <span class="ident">add_hidden_block</span></span>(<span>self, block)</span>
</code></dt>
<dd>
<section class="desc"><p>Save a hidden block created by current player.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block</code></strong> :&ensp;<code>Block</code></dt>
<dd>new hidden block to be save</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_hidden_block(self, block):

    &#34;&#34;&#34;Save a hidden block created by current player.
    
    Parameters
    ----------
    
    block : Block
        new hidden block to be save&#34;&#34;&#34;

    self.hidden_blocks.append(block)</code></pre>
</details>
</dd>
<dt id="blocksim.players.DefPlayerRandom.add_known_block"><code class="name flex">
<span>def <span class="ident">add_known_block</span></span>(<span>self, block)</span>
</code></dt>
<dd>
<section class="desc"><p>Save a hidden block created by another player.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block</code></strong> :&ensp;<code>Block</code></dt>
<dd>block to be saved</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_known_block(self, block):

    &#34;&#34;&#34;Save a hidden block created by another player.
    
    Parameters
    ----------
    
    block : Block
        block to be saved&#34;&#34;&#34;

    self.known_blocks.append(block)</code></pre>
</details>
</dd>
<dt id="blocksim.players.DefPlayerRandom.delete_hidden_block"><code class="name flex">
<span>def <span class="ident">delete_hidden_block</span></span>(<span>self, block)</span>
</code></dt>
<dd>
<section class="desc"><p>Delete reference to hidden block created by the current player after
revealing it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block</code></strong> :&ensp;<code>Block</code></dt>
<dd>block to be forgotten</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def delete_hidden_block(self, block):

    &#34;&#34;&#34;Delete reference to hidden block created by the current player after
    revealing it.
    
    Parameters
    ----------
    
    block : Block
        block to be forgotten&#34;&#34;&#34;

    self.hidden_blocks.remove(block)</code></pre>
</details>
</dd>
<dt id="blocksim.players.DefPlayerRandom.inform"><code class="name flex">
<span>def <span class="ident">inform</span></span>(<span>self, struct, end=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Choose blocks to communicate to other players. Don't communicate any
block.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>struct</code></strong> :&ensp;<code>Structure</code></dt>
<dd>data structure of the simulation</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>bool</code></dt>
<dd>flag indicating whether the method is being called after the
simulation has ended or before that</dd>
</dl>
<h2 id="results">Results</h2>
<dl>
<dt><strong><code>com_blocks</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary indicating which blocks to communicate to which players</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def inform(self, struct, end=False):

    &#34;&#34;&#34;Choose blocks to communicate to other players. Don&#39;t communicate any
    block.
    
    Parameters
    ----------
    
    struct : Structure
        data structure of the simulation
    end : bool
        flag indicating whether the method is being called after the
        simulation has ended or before that
        
    Results
    -------
    
    com_blocks : dict
        dictionary indicating which blocks to communicate to which players&#34;&#34;&#34;

    return dict()</code></pre>
</details>
</dd>
<dt id="blocksim.players.DefPlayerRandom.publish"><code class="name flex">
<span>def <span class="ident">publish</span></span>(<span>self, struct, end=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Choose blocks to reveal. Reveal all hidden blocks.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>struct</code></strong> :&ensp;<code>Structure</code></dt>
<dd>data structure of the simulation</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>bool</code></dt>
<dd>flag indicating whether the method is being called after the
simulation has ended or before that</dd>
</dl>
<h2 id="results">Results</h2>
<dl>
<dt><strong><code>pub_blocks</code></strong> :&ensp;<code>set</code></dt>
<dd>set containing blocks to be revealed</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def publish(self, struct, end=False):

    &#34;&#34;&#34;Choose blocks to reveal. Reveal all hidden blocks.
    
    Parameters
    ----------
    
    struct : Structure
        data structure of the simulation
    end : bool
        flag indicating whether the method is being called after the
        simulation has ended or before that
        
    Results
    -------
    
    pub_blocks : set
        set containing blocks to be revealed&#34;&#34;&#34;

    prev_blocks = self.hidden_blocks
    self.hidden_blocks = []
    return set(prev_blocks)</code></pre>
</details>
</dd>
<dt id="blocksim.players.DefPlayerRandom.strat"><code class="name flex">
<span>def <span class="ident">strat</span></span>(<span>self, struct)</span>
</code></dt>
<dd>
<section class="desc"><p>Choose a block to mine on top of. Choose a random block from the
deepest blocks in the structure.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>struct</code></strong> :&ensp;<code>Structure</code></dt>
<dd>data structure of the simulation</dd>
</dl>
<h2 id="results">Results</h2>
<dl>
<dt><strong><code>block</code></strong> :&ensp;<code>Block</code></dt>
<dd>chosen block to mine on top of</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def strat(self, struct):

    &#34;&#34;&#34;Choose a block to mine on top of. Choose a random block from the
    deepest blocks in the structure.
    
    Parameters
    ----------
    
    struct : Structure
        data structure of the simulation
        
    Results
    -------
    
    block : Block
        chosen block to mine on top of&#34;&#34;&#34;

    return sample(struct.deep_blocks, 1)[0]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="blocksim.players.SelfPlayer"><code class="flex name class">
<span>class <span class="ident">SelfPlayer</span></span>
</code></dt>
<dd>
<section class="desc"><p>Generate player that uses the selfish strategy. Once the player discovers
a new block, they don't reveal it unless another branch catches up to its
depth decremented by one. For example, if the hidden branch that the player
has created has a depth of <code>n</code> and there is another branch of depth
<code>n - 2</code>, the player discloses every block that has a depth of <code>n - 1</code>
or less.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class SelfPlayer:

    &#34;&#34;&#34;Generate player that uses the selfish strategy. Once the player discovers
    a new block, they don&#39;t reveal it unless another branch catches up to its
    depth decremented by one. For example, if the hidden branch that the player
    has created has a depth of ``n`` and there is another branch of depth
    ``n - 2``, the player discloses every block that has a depth of ``n - 1``
    or less.&#34;&#34;&#34;

    def __init__(self, name):

        &#34;&#34;&#34;Parameters
        ----------
        
        name : string
            identifier for the player&#34;&#34;&#34;

        self.name = name
        self.hidden_blocks = []
        self.known_blocks = []
        self.just_forked = False
        self.first_block = None
        self.last_published = None

    def add_hidden_block(self, block):

        &#34;&#34;&#34;Save a hidden block created by current player.
        
        Parameters
        ----------
        
        block : Block
            new hidden block to be save&#34;&#34;&#34;

        self.hidden_blocks.append(block)

    def delete_hidden_block(self, block):

        &#34;&#34;&#34;Delete reference to hidden block created by the current player after
        revealing it.
        
        Parameters
        ----------
        
        block : Block
            block to be forgotten&#34;&#34;&#34;

        self.hidden_blocks.remove(block)
    
    def add_known_block(self, block):

        &#34;&#34;&#34;Save a hidden block created by another player.
        
        Parameters
        ----------
        
        block : Block
            block to be saved&#34;&#34;&#34;

        self.known_blocks.append(block)

    def strat(self, struct):

        &#34;&#34;&#34;Choose a block to mine on top of. Chooses the same way that the
        default strategy would, unless the player has hidden blocks, in which
        case they mine on top of the last hidden block they have placed.
        
        Parameters
        ----------
        
        struct : Structure
            data structure of the simulation
            
        Results
        -------
        
        block : Block
            chosen block to mine on top of&#34;&#34;&#34;

        if self.hidden_blocks:
            return self.hidden_blocks[-1]
        
        next_blocks = struct.deep_blocks.copy()

        if self.last_published is not None and self.last_published.depth == struct.depth:
            if len(struct.deep_blocks) == 1:
                self.just_forked = True
            sel_block = self.last_published
        else:
            sel_block = next_blocks.pop()
            self.just_forked = True

        return sel_block

    def publish(self, struct, end=False):

        &#34;&#34;&#34;Choose blocks to reveal. As explained in the documentation for
        SelfPlayer, one only reveals a block if another branch has caught
        up with its depth decremented by one.
        
        Parameters
        ----------
        
        struct : Structure
            data structure of the simulation
        end : bool
            flag indicating whether the method is being called after the
            simulation has ended or before that
            
        Results
        -------
        
        pub_blocks : set
            set containing blocks to be revealed&#34;&#34;&#34;

        if end:
            prev_blocks = self.hidden_blocks
            self.hidden_blocks = list(filter(lambda x: x.parent.hidden, self.hidden_blocks))
            return set(filter(lambda x: not x.parent.hidden, prev_blocks))

        if self.just_forked:
            self.just_forked = False
            self.first_block = self.hidden_blocks[-1]
            return set()
        elif self.hidden_blocks:
            if self.hidden_blocks == [self.first_block]:
                if self.first_block.depth == struct.depth:
                    prev_blocks = self.hidden_blocks
                    self.hidden_blocks = []
                    self.last_published = self.first_block
                    return set(prev_blocks)
                else:
                    return set()
            else:
                if self.hidden_blocks[-1].depth &lt;= struct.depth + 1:
                    prev_blocks = self.hidden_blocks
                    self.hidden_blocks = list(filter(lambda x: x.parent.hidden, self.hidden_blocks))
                    publish = set(filter(lambda x: not x.parent.hidden, prev_blocks))
                    self.last_published = max(publish, key=lambda x: x.depth)
                    return publish
                else:
                    prev_blocks = self.hidden_blocks
                    self.hidden_blocks = list(filter(lambda x: x.parent.hidden or x.depth &gt; struct.depth, self.hidden_blocks))
                    publish = set(filter(lambda x: not x.parent.hidden and x.depth &lt;= struct.depth, prev_blocks))
                    self.last_published = max(publish, default=self.last_published, key=lambda x: x.depth)
                    return publish
        else:
            return set()

    def inform(self, struct, end=False):

        &#34;&#34;&#34;Choose blocks to communicate to other players. Don&#39;t communicate any
        block.
        
        Parameters
        ----------
        
        struct : Structure
            data structure of the simulation
        end : bool
            flag indicating whether the method is being called after the
            simulation has ended or before that
            
        Results
        -------
        
        com_blocks : dict
            dictionary indicating which blocks to communicate to which players&#34;&#34;&#34;

        return dict()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="blocksim.players.SelfPlayer.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code></dt>
<dd>identifier for the player</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def __init__(self, name):

    &#34;&#34;&#34;Parameters
    ----------
    
    name : string
        identifier for the player&#34;&#34;&#34;

    self.name = name
    self.hidden_blocks = []
    self.known_blocks = []
    self.just_forked = False
    self.first_block = None
    self.last_published = None</code></pre>
</details>
</dd>
<dt id="blocksim.players.SelfPlayer.add_hidden_block"><code class="name flex">
<span>def <span class="ident">add_hidden_block</span></span>(<span>self, block)</span>
</code></dt>
<dd>
<section class="desc"><p>Save a hidden block created by current player.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block</code></strong> :&ensp;<code>Block</code></dt>
<dd>new hidden block to be save</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_hidden_block(self, block):

    &#34;&#34;&#34;Save a hidden block created by current player.
    
    Parameters
    ----------
    
    block : Block
        new hidden block to be save&#34;&#34;&#34;

    self.hidden_blocks.append(block)</code></pre>
</details>
</dd>
<dt id="blocksim.players.SelfPlayer.add_known_block"><code class="name flex">
<span>def <span class="ident">add_known_block</span></span>(<span>self, block)</span>
</code></dt>
<dd>
<section class="desc"><p>Save a hidden block created by another player.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block</code></strong> :&ensp;<code>Block</code></dt>
<dd>block to be saved</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_known_block(self, block):

    &#34;&#34;&#34;Save a hidden block created by another player.
    
    Parameters
    ----------
    
    block : Block
        block to be saved&#34;&#34;&#34;

    self.known_blocks.append(block)</code></pre>
</details>
</dd>
<dt id="blocksim.players.SelfPlayer.delete_hidden_block"><code class="name flex">
<span>def <span class="ident">delete_hidden_block</span></span>(<span>self, block)</span>
</code></dt>
<dd>
<section class="desc"><p>Delete reference to hidden block created by the current player after
revealing it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block</code></strong> :&ensp;<code>Block</code></dt>
<dd>block to be forgotten</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def delete_hidden_block(self, block):

    &#34;&#34;&#34;Delete reference to hidden block created by the current player after
    revealing it.
    
    Parameters
    ----------
    
    block : Block
        block to be forgotten&#34;&#34;&#34;

    self.hidden_blocks.remove(block)</code></pre>
</details>
</dd>
<dt id="blocksim.players.SelfPlayer.inform"><code class="name flex">
<span>def <span class="ident">inform</span></span>(<span>self, struct, end=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Choose blocks to communicate to other players. Don't communicate any
block.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>struct</code></strong> :&ensp;<code>Structure</code></dt>
<dd>data structure of the simulation</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>bool</code></dt>
<dd>flag indicating whether the method is being called after the
simulation has ended or before that</dd>
</dl>
<h2 id="results">Results</h2>
<dl>
<dt><strong><code>com_blocks</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary indicating which blocks to communicate to which players</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def inform(self, struct, end=False):

    &#34;&#34;&#34;Choose blocks to communicate to other players. Don&#39;t communicate any
    block.
    
    Parameters
    ----------
    
    struct : Structure
        data structure of the simulation
    end : bool
        flag indicating whether the method is being called after the
        simulation has ended or before that
        
    Results
    -------
    
    com_blocks : dict
        dictionary indicating which blocks to communicate to which players&#34;&#34;&#34;

    return dict()</code></pre>
</details>
</dd>
<dt id="blocksim.players.SelfPlayer.publish"><code class="name flex">
<span>def <span class="ident">publish</span></span>(<span>self, struct, end=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Choose blocks to reveal. As explained in the documentation for
SelfPlayer, one only reveals a block if another branch has caught
up with its depth decremented by one.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>struct</code></strong> :&ensp;<code>Structure</code></dt>
<dd>data structure of the simulation</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>bool</code></dt>
<dd>flag indicating whether the method is being called after the
simulation has ended or before that</dd>
</dl>
<h2 id="results">Results</h2>
<dl>
<dt><strong><code>pub_blocks</code></strong> :&ensp;<code>set</code></dt>
<dd>set containing blocks to be revealed</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def publish(self, struct, end=False):

    &#34;&#34;&#34;Choose blocks to reveal. As explained in the documentation for
    SelfPlayer, one only reveals a block if another branch has caught
    up with its depth decremented by one.
    
    Parameters
    ----------
    
    struct : Structure
        data structure of the simulation
    end : bool
        flag indicating whether the method is being called after the
        simulation has ended or before that
        
    Results
    -------
    
    pub_blocks : set
        set containing blocks to be revealed&#34;&#34;&#34;

    if end:
        prev_blocks = self.hidden_blocks
        self.hidden_blocks = list(filter(lambda x: x.parent.hidden, self.hidden_blocks))
        return set(filter(lambda x: not x.parent.hidden, prev_blocks))

    if self.just_forked:
        self.just_forked = False
        self.first_block = self.hidden_blocks[-1]
        return set()
    elif self.hidden_blocks:
        if self.hidden_blocks == [self.first_block]:
            if self.first_block.depth == struct.depth:
                prev_blocks = self.hidden_blocks
                self.hidden_blocks = []
                self.last_published = self.first_block
                return set(prev_blocks)
            else:
                return set()
        else:
            if self.hidden_blocks[-1].depth &lt;= struct.depth + 1:
                prev_blocks = self.hidden_blocks
                self.hidden_blocks = list(filter(lambda x: x.parent.hidden, self.hidden_blocks))
                publish = set(filter(lambda x: not x.parent.hidden, prev_blocks))
                self.last_published = max(publish, key=lambda x: x.depth)
                return publish
            else:
                prev_blocks = self.hidden_blocks
                self.hidden_blocks = list(filter(lambda x: x.parent.hidden or x.depth &gt; struct.depth, self.hidden_blocks))
                publish = set(filter(lambda x: not x.parent.hidden and x.depth &lt;= struct.depth, prev_blocks))
                self.last_published = max(publish, default=self.last_published, key=lambda x: x.depth)
                return publish
    else:
        return set()</code></pre>
</details>
</dd>
<dt id="blocksim.players.SelfPlayer.strat"><code class="name flex">
<span>def <span class="ident">strat</span></span>(<span>self, struct)</span>
</code></dt>
<dd>
<section class="desc"><p>Choose a block to mine on top of. Chooses the same way that the
default strategy would, unless the player has hidden blocks, in which
case they mine on top of the last hidden block they have placed.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>struct</code></strong> :&ensp;<code>Structure</code></dt>
<dd>data structure of the simulation</dd>
</dl>
<h2 id="results">Results</h2>
<dl>
<dt><strong><code>block</code></strong> :&ensp;<code>Block</code></dt>
<dd>chosen block to mine on top of</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def strat(self, struct):

    &#34;&#34;&#34;Choose a block to mine on top of. Chooses the same way that the
    default strategy would, unless the player has hidden blocks, in which
    case they mine on top of the last hidden block they have placed.
    
    Parameters
    ----------
    
    struct : Structure
        data structure of the simulation
        
    Results
    -------
    
    block : Block
        chosen block to mine on top of&#34;&#34;&#34;

    if self.hidden_blocks:
        return self.hidden_blocks[-1]
    
    next_blocks = struct.deep_blocks.copy()

    if self.last_published is not None and self.last_published.depth == struct.depth:
        if len(struct.deep_blocks) == 1:
            self.just_forked = True
        sel_block = self.last_published
    else:
        sel_block = next_blocks.pop()
        self.just_forked = True

    return sel_block</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="blocksim" href="index.html">blocksim</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="blocksim.players.AFPlayer" href="#blocksim.players.AFPlayer">AFPlayer</a></code></h4>
<ul class="two-column">
<li><code><a title="blocksim.players.AFPlayer.__init__" href="#blocksim.players.AFPlayer.__init__">__init__</a></code></li>
<li><code><a title="blocksim.players.AFPlayer.add_hidden_block" href="#blocksim.players.AFPlayer.add_hidden_block">add_hidden_block</a></code></li>
<li><code><a title="blocksim.players.AFPlayer.add_known_block" href="#blocksim.players.AFPlayer.add_known_block">add_known_block</a></code></li>
<li><code><a title="blocksim.players.AFPlayer.delete_hidden_block" href="#blocksim.players.AFPlayer.delete_hidden_block">delete_hidden_block</a></code></li>
<li><code><a title="blocksim.players.AFPlayer.inform" href="#blocksim.players.AFPlayer.inform">inform</a></code></li>
<li><code><a title="blocksim.players.AFPlayer.publish" href="#blocksim.players.AFPlayer.publish">publish</a></code></li>
<li><code><a title="blocksim.players.AFPlayer.strat" href="#blocksim.players.AFPlayer.strat">strat</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="blocksim.players.DefPlayer" href="#blocksim.players.DefPlayer">DefPlayer</a></code></h4>
<ul class="two-column">
<li><code><a title="blocksim.players.DefPlayer.__init__" href="#blocksim.players.DefPlayer.__init__">__init__</a></code></li>
<li><code><a title="blocksim.players.DefPlayer.add_hidden_block" href="#blocksim.players.DefPlayer.add_hidden_block">add_hidden_block</a></code></li>
<li><code><a title="blocksim.players.DefPlayer.add_known_block" href="#blocksim.players.DefPlayer.add_known_block">add_known_block</a></code></li>
<li><code><a title="blocksim.players.DefPlayer.delete_hidden_block" href="#blocksim.players.DefPlayer.delete_hidden_block">delete_hidden_block</a></code></li>
<li><code><a title="blocksim.players.DefPlayer.inform" href="#blocksim.players.DefPlayer.inform">inform</a></code></li>
<li><code><a title="blocksim.players.DefPlayer.publish" href="#blocksim.players.DefPlayer.publish">publish</a></code></li>
<li><code><a title="blocksim.players.DefPlayer.strat" href="#blocksim.players.DefPlayer.strat">strat</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="blocksim.players.DefPlayerRandom" href="#blocksim.players.DefPlayerRandom">DefPlayerRandom</a></code></h4>
<ul class="two-column">
<li><code><a title="blocksim.players.DefPlayerRandom.__init__" href="#blocksim.players.DefPlayerRandom.__init__">__init__</a></code></li>
<li><code><a title="blocksim.players.DefPlayerRandom.add_hidden_block" href="#blocksim.players.DefPlayerRandom.add_hidden_block">add_hidden_block</a></code></li>
<li><code><a title="blocksim.players.DefPlayerRandom.add_known_block" href="#blocksim.players.DefPlayerRandom.add_known_block">add_known_block</a></code></li>
<li><code><a title="blocksim.players.DefPlayerRandom.delete_hidden_block" href="#blocksim.players.DefPlayerRandom.delete_hidden_block">delete_hidden_block</a></code></li>
<li><code><a title="blocksim.players.DefPlayerRandom.inform" href="#blocksim.players.DefPlayerRandom.inform">inform</a></code></li>
<li><code><a title="blocksim.players.DefPlayerRandom.publish" href="#blocksim.players.DefPlayerRandom.publish">publish</a></code></li>
<li><code><a title="blocksim.players.DefPlayerRandom.strat" href="#blocksim.players.DefPlayerRandom.strat">strat</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="blocksim.players.SelfPlayer" href="#blocksim.players.SelfPlayer">SelfPlayer</a></code></h4>
<ul class="two-column">
<li><code><a title="blocksim.players.SelfPlayer.__init__" href="#blocksim.players.SelfPlayer.__init__">__init__</a></code></li>
<li><code><a title="blocksim.players.SelfPlayer.add_hidden_block" href="#blocksim.players.SelfPlayer.add_hidden_block">add_hidden_block</a></code></li>
<li><code><a title="blocksim.players.SelfPlayer.add_known_block" href="#blocksim.players.SelfPlayer.add_known_block">add_known_block</a></code></li>
<li><code><a title="blocksim.players.SelfPlayer.delete_hidden_block" href="#blocksim.players.SelfPlayer.delete_hidden_block">delete_hidden_block</a></code></li>
<li><code><a title="blocksim.players.SelfPlayer.inform" href="#blocksim.players.SelfPlayer.inform">inform</a></code></li>
<li><code><a title="blocksim.players.SelfPlayer.publish" href="#blocksim.players.SelfPlayer.publish">publish</a></code></li>
<li><code><a title="blocksim.players.SelfPlayer.strat" href="#blocksim.players.SelfPlayer.strat">strat</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.5.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>